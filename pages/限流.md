- 当流量超过服务设计时的承载量时，通过一定的算法，将无法处理的流量丢弃，以保证服务的稳定性
- 概念
	- 阈值： 在一个单位时间内允许的请求量，如QPS限制为10，说明1秒内最多接受10次请求
	- 拒绝策略：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等
- 算法
	- 计数器算法/固定窗口算法
		- 常见最容易实现的限流算法
		- 原理： 记录一定时间内的请求数量，将超过阈值的请求拦截掉
		- ![计数器算法](../assets/image_1703063049851_0.png){:height 77, :width 245}
		- 缺点：在临界区见容易触发错误的限流判定
			- 如：假设设定请求记录时间为1S，限流触发阈值为2，在上一个记录区间的最后100ms和当前记录区间的前100ms都发生了接近阈值的请求量2，但是这样就无法触发限流，但是请求超过了系统的最大负载
		- 实现
			- ```java
			  /**
			   * @author https://www.wdbyte.com
			   */
			  public class RateLimiterSimpleWindow {
			      // 阈值
			      private static Integer QPS = 2;
			      // 时间窗口（毫秒）
			      private static long TIME_WINDOWS = 1000;
			      // 计数器
			      private static AtomicInteger REQ_COUNT = new AtomicInteger();
			      
			      private static long START_TIME = System.currentTimeMillis();
			  
			      public synchronized static boolean tryAcquire() {
			          if ((System.currentTimeMillis() - START_TIME) > TIME_WINDOWS) {
			              REQ_COUNT.set(0);
			              START_TIME = System.currentTimeMillis();
			          }
			          return REQ_COUNT.incrementAndGet() <= QPS;
			      }
			  
			      public static void main(String[] args) throws InterruptedException {
			          for (int i = 0; i < 10; i++) {
			              Thread.sleep(250);
			              LocalTime now = LocalTime.now();
			              if (!tryAcquire()) {
			                  System.out.println(now + " 被限流");
			              } else {
			                  System.out.println(now + " 做点什么");
			              }
			          }
			      }
			  }
			  ```
	- 滑动窗口
		- 是计数器算法的改进，解决了上面的问题
		- ![滑动窗口算法](../assets/image_1703063177560_0.png)
		- 实现
			- ```java
			  public class CounterSildeWindowLimiter {
			  
			      private int windowSize; //窗口大小，毫秒为单位
			      private int limit;//窗口内限流大小
			      private int splitNum;//切分小窗口的数目大小
			      private int[] counters;//每个小窗口的计数数组
			      private int index;//当前小窗口计数器的索引
			      private long startTime;//窗口开始时间
			  
			      private CounterSildeWindowLimiter(){}
			  
			      public CounterSildeWindowLimiter(int windowSize, int limit, int splitNum){
			          this.limit = limit;
			          this.windowSize = windowSize;
			          this.splitNum = splitNum;
			          counters = new int[splitNum];
			          index = 0;
			          startTime = System.currentTimeMillis();
			      }
			  
			      //请求到达后先调用本方法，若返回true，则请求通过，否则限流
			      public synchronized boolean tryAcquire(){
			          long curTime = System.currentTimeMillis();
			          long windowsNum = Math.max(curTime - windowSize - startTime,0) / (windowSize / splitNum);//计算滑动小窗口的数量
			          slideWindow(windowsNum);//滑动窗口
			          int count = 0;
			          for(int i = 0;i < splitNum;i ++){
			              count += counters[i];
			          }
			          if(count >= limit){
			              return false;
			          }else{
			              counters[index] ++;
			              return true;
			          }
			      }
			  
			      private synchronized void slideWindow(long windowsNum){
			          if(windowsNum == 0)
			              return;
			          long slideNum = Math.min(windowsNum,splitNum);
			          for(int i = 0;i < slideNum;i ++){
			              index = (index + 1) % splitNum;
			              counters[index] = 0;
			          }
			          startTime = startTime + windowsNum * (windowSize / splitNum);//更新滑动窗口时间
			      }
			  
			      //测试
			      public static void main(String[] args) throws InterruptedException {
			          //每秒20个请求
			          int limit = 20;
			          CounterSildeWindowLimiter counterSildeWindowLimiter = new CounterSildeWindowLimiter(1000,limit,10);
			          int count = 0;
			  
			          Thread.sleep(3000);
			          //计数器滑动窗口算法模拟100组间隔30ms的50次请求
			          System.out.println("计数器滑动窗口算法测试开始");
			          System.out.println("开始模拟100组间隔150ms的50次请求");
			          int faliCount = 0;
			          for(int j = 0;j < 100;j ++){
			              count = 0;
			              for(int i = 0;i < 50;i ++){
			                  if(counterSildeWindowLimiter.tryAcquire()){
			                      count ++;
			                  }
			              }
			              Thread.sleep(150);
			              //模拟50次请求，看多少能通过
			              for(int i = 0;i < 50;i ++){
			                  if(counterSildeWindowLimiter.tryAcquire()){
			                      count ++;
			                  }
			              }
			              if(count > limit){
			                  System.out.println("时间窗口内放过的请求超过阈值，放过的请求数" + count + ",限流：" + limit);
			                  faliCount ++;
			              }
			              Thread.sleep((int)(Math.random() * 100));
			          }
			          System.out.println("计数器滑动窗口算法测试结束，100组间隔150ms的50次请求模拟完成，限流失败组数：" + faliCount);
			          System.out.println("===========================================================================================");
			  
			          //计数器固定窗口算法模拟100组间隔30ms的50次请求
			          System.out.println("计数器固定窗口算法测试开始");
			          //模拟100组间隔30ms的50次请求
			          CounterLimiter counterLimiter = new CounterLimiter(1000,limit);
			          System.out.println("开始模拟100组间隔150ms的50次请求");
			          faliCount = 0;
			          for(int j = 0;j < 100;j ++){
			              count = 0;
			              for(int i = 0;i < 50;i ++){
			                  if(counterLimiter.tryAcquire()){
			                      count ++;
			                  }
			              }
			              Thread.sleep(150);
			              //模拟50次请求，看多少能通过
			              for(int i = 0;i < 50;i ++){
			                  if(counterLimiter.tryAcquire()){
			                      count ++;
			                  }
			              }
			              if(count > limit){
			                  System.out.println("时间窗口内放过的请求超过阈值，放过的请求数" + count + ",限流：" + limit);
			                  faliCount ++;
			              }
			              Thread.sleep((int)(Math.random() * 100));
			          }
			          System.out.println("计数器滑动窗口算法测试结束，100组间隔150ms的50次请求模拟完成，限流失败组数：" + faliCount);
			      }
			  }
			  ```
	- 滑动日志算法
		- 记录下所有请求的时间点，新请求到时先判断最近指定时间范围内的请求数量是否超过阈值，由此来确定是否达限流，限流比较准确，但是因为要记录每次请求的时间点，所以占用内存较多
	- 漏桶算法
	- 令牌桶
	-