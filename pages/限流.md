- 当流量超过服务设计时的承载量时，通过一定的算法，将无法处理的流量丢弃，以保证服务的稳定性
- 概念
	- 阈值： 在一个单位时间内允许的请求量，如QPS限制为10，说明1秒内最多接受10次请求
	- 拒绝策略：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等
- 算法
	- 计数器算法/固定窗口算法
		- 常见最容易实现的限流算法
		- 原理： 记录一定时间内的请求数量，将超过阈值的请求拦截掉
		- ![计数器算法](../assets/image_1703063049851_0.png){:height 77, :width 245}
		- 缺点：在临界区见容易触发错误的限流判定
			- 如：假设设定请求记录时间为1S，限流触发阈值为2，在上一个记录区间的最后100ms和当前记录区间的前100ms都发生了接近阈值的请求量2，但是这样就无法触发限流，但是请求超过了系统的最大负载
		- 实现
			- ```java
			  public class CounterLimiter {
			      private int windowSize; //窗口大小，毫秒为单位
			      private int limit;//窗口内限流大小
			      private AtomicInteger count;//当前窗口的计数器
			  
			      private CounterLimiter(){}
			  
			      public CounterLimiter(int windowSize,int limit){
			          this.limit = limit;
			          this.windowSize = windowSize;
			          count = new AtomicInteger(0);
			  
			          //开启一个线程，达到窗口结束时清空count
			          new Thread(new Runnable() {
			              @Override
			              public void run() {
			                  while(true){
			                      count.set(0);
			                      try {
			                          Thread.sleep(windowSize);
			                      } catch (InterruptedException e) {
			                          e.printStackTrace();
			                      }
			                  }
			              }
			          }).start();
			      }
			  
			      //请求到达后先调用本方法，若返回true，则请求通过，否则限流
			      public boolean tryAcquire(){
			          int newCount = count.addAndGet(1);
			          if(newCount > limit){
			              return false;
			          }else{
			              return true;
			          }
			      }
			    
			      //测试
			      public static void main(String[] args) throws InterruptedException {
			          //每秒20个请求
			          CounterLimiter counterLimiter = new CounterLimiter(1000,20);
			          int count = 0;
			          //模拟50次请求，看多少能通过
			          for(int i = 0;i < 50;i ++){
			              if(counterLimiter.tryAcquire()){
			                  count ++;
			              }
			          }
			          System.out.println("第一拨50次请求中通过：" + count + ",限流：" + (50 - count));
			          //过一秒再请求
			          Thread.sleep(1000);
			          //模拟50次请求，看多少能通过
			          count = 0;
			          for(int i = 0;i < 50;i ++){
			              if(counterLimiter.tryAcquire()){
			                  count ++;
			              }
			          }
			          System.out.println("第二拨50次请求中通过：" + count + ",限流：" + (50 - count));
			      }
			  }
			  ```
	- 滑动窗口
		- 是计数器算法的改进，解决了上面的问题
		- ![滑动窗口算法](../assets/image_1703063177560_0.png)
	- 滑动日志算法
		- 记录下所有请求的时间点，新请求到时先判断最近指定时间范围内的请求数量是否超过阈值，由此来确定是否达限流，限流比较准确，但是因为要记录每次请求的时间点，所以占用内存较多
	- 漏桶算法
	- 令牌桶
	-