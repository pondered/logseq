- 类别
	- 偏向锁、轻量级锁、重量级锁
		- 特指`synchronized`锁的状态，通过在对象头中的`mark word`来表明锁的状态
		- 偏向锁
			- 思想：如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就可以了
			- 一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问并尝试获取锁时，就会把这个线程记录下来，以后如果尝试获取锁的线程正时偏向锁的拥有者，就可以直接获取锁，开销和小，性能最好
		- 轻量级锁
			- 在很多情况下，`synchronized`中的代码是被多个线程交替执行的，而不是同事执行的，也就是说并不存在实际的竞争，或者是只有段时间的锁竞争，用 `CAS` 就可以解决，这种情况下，用完全互斥的重量级锁时没必要的
			- 轻量级锁是指当锁原来是偏向锁时，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞
		- 重量级锁
			- 重量级锁是互斥锁，是利用操作系统的同步机制实现的，所以开销比较大。当多个线程直接有实际竞争切锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。
			- 重量级锁会让其他申请却拿不到锁的线程进入阻塞状态
		- ![锁升级](../assets/image_1704728002758_0.png)
	- 可重入锁、不可重入锁
		- 可重入锁
			- 当前线程已经持有这把锁，可以在不释放的情况下，再次重新获取这把锁
			- `ReentrantLock`
		- 不可重入锁
			- 虽然当前线程持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取
	- 共享锁、独占锁
		- 共享锁
			- 同一把锁可以被多个线程同时获得
			- 读锁：可以同时被多个线程持有
		- 独占锁
			- 同一把锁只能同时被一个线程获得
			- 写锁：只能被一个线程持有
	- 公平锁、非公平锁
		- 公平锁
			- 如果线程现在拿不到这把锁，那么线程就会进入等待，开始排队，在等待队列里等待时间最长的线程会优先获得这把锁
		- 非公平锁
			- 会在一定情况下，忽略已经在排队的线程，发生插队现象
	- 悲观锁、乐观锁
		- 悲观锁
			- 在获取资源之前，必须先拿到锁，以便达到**独占**的状态，当前线程在操作资源时，其他线程由于不能拿到锁，所以其他线程不会有影响
		- 乐观锁
			- 不要求在获取资源前拿到锁，也不会锁住资源
			- 乐观锁利用 `CAS` 的理念，在不独占资源的情况下，完成对资源的修改
	- 自旋锁、非自旋锁
		- 自旋锁
			- 如果线程现在拿不到锁，并不直接陷入阻塞或者释放CPU资源，而是开始利用循环，不停的尝试获取锁，这个循环过程被比喻为`自旋`
		- 非自旋锁
			- 如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如排队、陷入阻塞等
	- 可中断锁、不可中断锁
		- 可中断锁
			- 在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他事情，不需要一直等到获取锁
		- 不可中断锁
			- `synchronized`表示的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等拿到锁以后才能进行其他的逻辑处理